}
if (norm(as.matrix(R),type = '2') == 0) {
r = 0
} else {
r = min(1,yita/norm(as.matrix(R),type = '2'))
}
Ty = (1 - r) * T + r*y
iterdis = norm(as.matrix(Ty - y),type = '1') - tol * norm(as.matrix(y),type = '1')
iter = iter + 1
y = Ty
}
return(y)
}
simplex_projection <- function(v,b){
if (b < 0)
{print('error')}
v = (v > 0) * v
u = sort(v, decreasing = TRUE)
sv = cumsum(u)
rho = tail(which(u > (sv - b)/c(1:length(u))),n = 1)
#print(rho)
#print((sv[rho]-b)/rho)
theta = max(0,(sv[rho] - b)/rho)
#print("theta")
#print(theta)
temp = v - theta
temp[temp < 0] = 0
w = temp
return(w)
}
#install.packages('R.matlab')
library("R.matlab")
path <- ('Data/')
#input
pathname <- file.path(path,'djia.mat')
data_1 <- as.vector(readMat(pathname))
#class(data_1)
#print(data_1)
data_matrix <- as.matrix(as.data.frame(data_1))
#class(data_matrix)
fid = "rmr.txt"
#implementation
parameters = c(5, 5, 0)
result = rmr(fid,data_matrix,parameters)
write.csv(file = "rmr.csv",result)
result[1]
result[2]
result[3]
cum_ret = result[1]
cum_ret = result[[1]]
cumsum_ret = result[[2]]
daily_ret = result[[3]]
ddval = ra_dd(cumsum_ret)
ddval
mddval = ra_mdd(cumsum_ret)
mddval
max(cumsum_ret)
rmr <- function(fid, data, varagins){
epsilon = varagins[1]
W = varagins[2]
tc = varagins[3]
output = rmr_run(fid, data,epsilon,tc, W)
return(output)
}
rmr_run <- function(fid,data,epsilon,tc,W) {
T = dim(data)[1]
N = dim(data)[2]
run_ret = NULL
total_ret = cbind(rep(1,T))
day_ret = cbind(rep(1,T))
day_weight = cbind(rep(1,N)/N)
day_weight_o = cbind(rep(0,N))
day_weight_n = cbind(rep(0,N))
turno = 0
data_close = matrix(1,T,N)
for (i in 2:T) {
data_close[i,] = data_close[i - 1,]*data[i,]
}
print(paste("Parameters tc:", tc))
k = 1
run_ret[k] = 1
for (t in 1:T) {
day_ret[t] = (data[t,] %*% day_weight) * (1 - tc/2  * sum(abs(day_weight - day_weight_o)))
run_ret[k] = run_ret[k] %*% day_ret[t]
total_ret[t] = run_ret[k]
day_weight_o = (day_weight * cbind(data[t,]))/day_ret[t]
if (t < T) {
day_weight_n = rmr_day_weight(data_close,data,t + 1,day_weight,W,epsilon)
turno = turno + sum(abs(day_weight_n - day_weight))
day_weight = day_weight_n
}
}
output = list(run_ret,total_ret,day_ret,turno)
return(output)
}
rmr_day_weight <- function(data_close, data, t1, day_weight,w,epsilon){
if (t1 < w + 2) {
x_t1 = data[t1 - 1,]
} else {
x_t1 = l1median_VaZh_z(data_close[(t1 - w):(t1 - 1),])/data_close[t1 - 1,]
}
if (norm(as.matrix(x_t1 - mean(x_t1))^2,type = '2') == 0) {
tao = 0
} else {
tao = min(0,((x_t1) %*% day_weight - epsilon)/(norm(as.matrix(x_t1 - mean(x_t1)),type = '2')^2))
}
day_weight = day_weight - tao * cbind(x_t1 - mean(x_t1))
day_weight = simplex_projection(day_weight,1)
return(day_weight)
}
l1median_VaZh_z <- function(X) {
medIn = apply(X,2,median)
zerotol = 1e-15
maxiter = 200
rn = dim(X)[1]
vn = dim(X)[2]
iterdis = 1
iter = 0
y = medIn
tol = 1e-9
while (iterdis > 0 && iter < maxiter) {
Tnum = rep(0,vn)
R = rep(0,vn)
Tden = 0
yita = 0
for (i in 1:rn) {
dist = norm(as.matrix(X[i,] - y),type = '2')
if (dist >= zerotol) {
Tnum = Tnum + X[i,]/dist
Tden = Tden + 1/dist
R = R + (X[i,] - y)/dist
} else {
yita = 1
}
}
if (Tden == 0) {
T = 0
} else {
T = Tnum/Tden
}
if (norm(as.matrix(R),type = '2') == 0) {
r = 0
} else {
r = min(1,yita/norm(as.matrix(R),type = '2'))
}
Ty = (1 - r) * T + r*y
iterdis = norm(as.matrix(Ty - y),type = '1') - tol * norm(as.matrix(y),type = '1')
iter = iter + 1
y = Ty
}
return(y)
}
simplex_projection <- function(v,b){
if (b < 0)
{print('error')}
v = (v > 0) * v
u = sort(v, decreasing = TRUE)
sv = cumsum(u)
rho = tail(which(u > (sv - b)/c(1:length(u))),n = 1)
#print(rho)
#print((sv[rho]-b)/rho)
theta = max(0,(sv[rho] - b)/rho)
#print("theta")
#print(theta)
temp = v - theta
temp[temp < 0] = 0
w = temp
return(w)
}
#install.packages('R.matlab')
library("R.matlab")
path <- ('Data/')
#input
pathname <- file.path(path,'djia.mat')
data_1 <- as.vector(readMat(pathname))
#class(data_1)
#print(data_1)
data_matrix <- as.matrix(as.data.frame(data_1))
#class(data_matrix)
fid = "rmr.txt"
#implementation
parameters = c(5, 5, 0)
result = rmr(fid,data_matrix,parameters)
write.csv(file = "rmr.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
best_run<-function(fid, data, tc)
{
output <- as.data.frame(data)
size_data<- dim(output)
n = size_data[1]
m = size_data[2]
data <- as.matrix(output)
# Variables for return, start with uniform weight
cum_ret = 1
cumprod_ret = matrix(1,c(n, 1))
daily_ret = matrix(1,c(n, 1))
ret_m = matrix(1,c(n, 2)) #cumprod_ret + daily_ret
day_weight = matrix(1,c(m, 1))/m
day_weight_o = matrix(0,c(m, 1))
daily_portfolio = matrix(0,nrow=n,ncol=m)
# print file head
write('------------------', file = fid, append = FALSE )
ln <- paste('Parameters [tc:', tc, ']')
write(ln, file = fid, append = TRUE )
write('day\t Daily Return\t Total return', file = fid, append = TRUE )
# Calculate wealth return for each stock
tmp_daily_ret = matrix(1,c(m, 1))
tmp_cumprod_ret = matrix(1,c(m, 1))
for (p in 1:n)
{
tmp_daily_ret = data[p, ]
tmp_cumprod_ret = tmp_cumprod_ret*tmp_daily_ret
}
# Find the maximum and its index
best_ind = which.max(tmp_cumprod_ret)
day_weight = matrix(0,c(m, 1))
day_weight[best_ind] <- 1
for (p in 1:n)
{
# Normalize the constraint, always useless
day_weight = day_weight/sum(day_weight)
daily_portfolio[p, ] = t(day_weight)
# Cal t's return and total return
daily_ret[p, ] = (data[p,]%*%day_weight)*(1-tc/2*sum(abs(day_weight-day_weight_o)))
cum_ret = cum_ret %*% daily_ret[p,]
cumprod_ret[p, ] = cum_ret;
# Adjust weight[p,] for the transaction cost issue
day_weight_o = day_weight*(data[p,])/(daily_ret[p, 1])
lns <- paste(p,'\t',daily_ret[p, 1],'\t',cumprod_ret[p, 1])
write(lns,file=fid,append=TRUE)
}
ln1 <- paste('BEST(tc=', tc,' ,Final return: ', cum_ret)
write(ln1, file=fid, append=TRUE)
write('------------------', file=fid, append=TRUE)
}
install.packages('rmatio')
library('rmatio')
fid <- 'b.txt'
data<- read.mat('D:/Files/NUS 2018 MFE/FE5209 Financial Econometrics/Project/OLPS-master/Data/djia.mat')
tc=0
best_run(fid,data,tc)
result = best_run(fid,data,tc)
result
result = best_run(fid,data,tc)
result
best_run<-function(fid, data, tc)
{
output <- as.data.frame(data)
size_data<- dim(output)
n = size_data[1]
m = size_data[2]
data <- as.matrix(output)
# Variables for return, start with uniform weight
cum_ret = 1
cumprod_ret = matrix(1,c(n, 1))
daily_ret = matrix(1,c(n, 1))
ret_m = matrix(1,c(n, 2)) #cumprod_ret + daily_ret
day_weight = matrix(1,c(m, 1))/m
day_weight_o = matrix(0,c(m, 1))
daily_portfolio = matrix(0,nrow=n,ncol=m)
# print file head
write('------------------', file = fid, append = FALSE )
ln <- paste('Parameters [tc:', tc, ']')
write(ln, file = fid, append = TRUE )
write('day\t Daily Return\t Total return', file = fid, append = TRUE )
# Calculate wealth return for each stock
tmp_daily_ret = matrix(1,c(m, 1))
tmp_cumprod_ret = matrix(1,c(m, 1))
for (p in 1:n)
{
tmp_daily_ret = data[p, ]
tmp_cumprod_ret = tmp_cumprod_ret*tmp_daily_ret
}
# Find the maximum and its index
best_ind = which.max(tmp_cumprod_ret)
day_weight = matrix(0,c(m, 1))
day_weight[best_ind] <- 1
for (p in 1:n)
{
# Normalize the constraint, always useless
day_weight = day_weight/sum(day_weight)
daily_portfolio[p, ] = t(day_weight)
# Cal t's return and total return
daily_ret[p, ] = (data[p,]%*%day_weight)*(1-tc/2*sum(abs(day_weight-day_weight_o)))
cum_ret = cum_ret %*% daily_ret[p,]
cumprod_ret[p, ] = cum_ret;
# Adjust weight[p,] for the transaction cost issue
day_weight_o = day_weight*(data[p,])/(daily_ret[p, 1])
lns <- paste(p,'\t',daily_ret[p, 1],'\t',cumprod_ret[p, 1])
write(lns,file=fid,append=TRUE)
}
ln1 <- paste('BEST(tc=', tc,' ,Final return: ', cum_ret)
write(ln1, file=fid, append=TRUE)
write('------------------', file=fid, append=TRUE)
return(ln1)
}
result = best_run(fid,data,tc)
result
best_run<-function(fid, data, tc)
{
output <- as.data.frame(data)
size_data<- dim(output)
n = size_data[1]
m = size_data[2]
data <- as.matrix(output)
# Variables for return, start with uniform weight
cum_ret = 1
cumprod_ret = matrix(1,c(n, 1))
daily_ret = matrix(1,c(n, 1))
ret_m = matrix(1,c(n, 2)) #cumprod_ret + daily_ret
day_weight = matrix(1,c(m, 1))/m
day_weight_o = matrix(0,c(m, 1))
daily_portfolio = matrix(0,nrow=n,ncol=m)
# print file head
write('------------------', file = fid, append = FALSE )
ln <- paste('Parameters [tc:', tc, ']')
write(ln, file = fid, append = TRUE )
write('day\t Daily Return\t Total return', file = fid, append = TRUE )
# Calculate wealth return for each stock
tmp_daily_ret = matrix(1,c(m, 1))
tmp_cumprod_ret = matrix(1,c(m, 1))
for (p in 1:n)
{
tmp_daily_ret = data[p, ]
tmp_cumprod_ret = tmp_cumprod_ret*tmp_daily_ret
}
# Find the maximum and its index
best_ind = which.max(tmp_cumprod_ret)
day_weight = matrix(0,c(m, 1))
day_weight[best_ind] <- 1
for (p in 1:n)
{
# Normalize the constraint, always useless
day_weight = day_weight/sum(day_weight)
daily_portfolio[p, ] = t(day_weight)
# Cal t's return and total return
daily_ret[p, ] = (data[p,]%*%day_weight)*(1-tc/2*sum(abs(day_weight-day_weight_o)))
cum_ret = cum_ret %*% daily_ret[p,]
cumprod_ret[p, ] = cum_ret;
# Adjust weight[p,] for the transaction cost issue
day_weight_o = day_weight*(data[p,])/(daily_ret[p, 1])
lns <- paste(p,'\t',daily_ret[p, 1],'\t',cumprod_ret[p, 1])
write(lns,file=fid,append=TRUE)
}
ln1 <- paste('BEST(tc=', tc,' ,Final return: ', cum_ret)
write(ln1, file=fid, append=TRUE)
write('------------------', file=fid, append=TRUE)
return(list(cumprod_ret,cumprod_ret,daily_ret))
}
result = best_run(fid,data,tc)
result
result[[1]]
best_run<-function(fid, data, tc)
{
output <- as.data.frame(data)
size_data<- dim(output)
n = size_data[1]
m = size_data[2]
data <- as.matrix(output)
# Variables for return, start with uniform weight
cum_ret = 1
cumprod_ret = matrix(1,c(n, 1))
daily_ret = matrix(1,c(n, 1))
ret_m = matrix(1,c(n, 2)) #cumprod_ret + daily_ret
day_weight = matrix(1,c(m, 1))/m
day_weight_o = matrix(0,c(m, 1))
daily_portfolio = matrix(0,nrow=n,ncol=m)
# print file head
write('------------------', file = fid, append = FALSE )
ln <- paste('Parameters [tc:', tc, ']')
write(ln, file = fid, append = TRUE )
write('day\t Daily Return\t Total return', file = fid, append = TRUE )
# Calculate wealth return for each stock
tmp_daily_ret = matrix(1,c(m, 1))
tmp_cumprod_ret = matrix(1,c(m, 1))
for (p in 1:n)
{
tmp_daily_ret = data[p, ]
tmp_cumprod_ret = tmp_cumprod_ret*tmp_daily_ret
}
# Find the maximum and its index
best_ind = which.max(tmp_cumprod_ret)
day_weight = matrix(0,c(m, 1))
day_weight[best_ind] <- 1
for (p in 1:n)
{
# Normalize the constraint, always useless
day_weight = day_weight/sum(day_weight)
daily_portfolio[p, ] = t(day_weight)
# Cal t's return and total return
daily_ret[p, ] = (data[p,]%*%day_weight)*(1-tc/2*sum(abs(day_weight-day_weight_o)))
cum_ret = cum_ret %*% daily_ret[p,]
cumprod_ret[p, ] = cum_ret;
# Adjust weight[p,] for the transaction cost issue
day_weight_o = day_weight*(data[p,])/(daily_ret[p, 1])
lns <- paste(p,'\t',daily_ret[p, 1],'\t',cumprod_ret[p, 1])
write(lns,file=fid,append=TRUE)
}
ln1 <- paste('BEST(tc=', tc,' ,Final return: ', cum_ret)
write(ln1, file=fid, append=TRUE)
write('------------------', file=fid, append=TRUE)
return(list(cum_ret,cumprod_ret,daily_ret))
}
result = best_run(fid,data,tc)
result
result[[1]]
result[[2]]
result[[3]]
library('rmatio')
fid <- 'best.txt'
data_matrix<- read.mat('D:/Files/NUS 2018 MFE/FE5209 Financial Econometrics/Project/OLPS-master/Data/djia.mat')
tc=0
result = best_run(fid,data_matrix,tc)
write.csv(file = "BEST.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
library('rmatio')
fid <- 'best.txt'
data_matrix<- read.mat('Data/djia.mat')
tc=0
result = best_run(fid,data_matrix,tc)
write.csv(file = "BEST.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
library('rmatio')
fid <- 'best.txt'
data_matrix<- read.mat('Data/djia.mat')
tc=0
result = best_run(fid,data_matrix,tc)
write.csv(file = "BEST.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
data.matrix()
data.matrix
data_matrix
RET_RF = 1.000156
NUM_TRADE = 252
n = dim(data)[1]
m = dim(data)[2]
market_daily_ret = cbind(rep(1,n))
x = cbind(rep(1,n),market_daily_ret - RET_RF)
nDays = length(data)
mddvec = cbind(rep(0,nDays))
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
result[[1]]
result[[2]]
result[[3]]
parameters = c(5, 5, 0)
result = rmr(fid,data_matrix,parameters)
write.csv(file = "rmr.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
parameters = c(5, 5, 0)
result = rmr(fid,data_matrix,parameters)
write.csv(file = "rmr.csv",result)
source("ra_result_analyze.R")
ra_result_analyze(data_matrix,result[[1]],result[[2]],result[[3]])
market_daily_ret = cbind(rep(1,n))
x = cbind(rep(1,n),market_daily_ret - RET_RF)
RET_RF = 1.000156
NUM_TRADE = 252
n = dim(data)[1]
m = dim(data)[2]
market_daily_ret = cbind(rep(1,n))
day_weight = cbind(rep(1, m))/m
for (t in 1:n) {
day_weight = day_weight/sum(day_weight)
market_daily_ret[t] = data[t,] %*% day_weight
day_weight = (day_weight * cbind(data[t,]))/market_daily_ret[t]
}
win_ratio = sum(daily_ret >= market_daily_ret)/n
# Statistical t-Tests
market_mu = colMeans(market_daily_ret) - 1
strategy_mu = mean(daily_ret) - 1
x = cbind(rep(1,n),market_daily_ret - RET_RF)
y = daily_ret - RET_RF
a = mldivide(x, y)
alpha = a[1]
beta = a[2]
strategy_se = sd(y - x %*% a)/sqrt(n)
t_stat = alpha / strategy_se
p_value = 1 - pt(t_stat,n-1)
# Risk adjusted return: APY, standard deviation, and annualized Sharpe Ratio
apy = (cum_ret)^(1/round(n/NUM_TRADE)) - 1
stdev = sd(daily_ret %*% sqrt(NUM_TRADE))
sr = (apy - 0.04)/stdev
# Risk adjusted return: DD, MDD and CR
ddval = ra_dd(cumsum_ret)
mddval = ra_mdd(cumsum_ret)
cr = apy/mddval
#Store all analyzed value
ra_ret = NULL
# Results for statistical t-test
ra_ret[1] = n
ra_ret[2] = strategy_mu
ra_ret[3] = market_mu
ra_ret[4] = win_ratio
ra_ret[5] = alpha
ra_ret[6] = beta
ra_ret[7] = t_stat
ra_ret[8] = p_value
# results for standard deviation of return and sharpe ratio.
ra_ret[9] = apy
ra_ret[10] = stdev
ra_ret[11] = sr
# Results for maximum drawdown analysis and calmar ratio.
ra_ret[12] = ddval
ra_ret[13] = mddval
ra_ret[14] = cr
result = rmr(fid,data_matrix,parameters)
